#include "stm32l0xx.h"
#include <stdint.h>
#include <stdbool.h>
#include <uart2.h>
#include "circular_buffer.h"
#include "gpio.h"

#ifndef UART1_RX_BUFFER_SIZE
#define UART1_RX_BUFFER_SIZE 64
#endif

NEW_CIRC_BUFFER(uartTxBuff, 64);
NEW_CIRC_BUFFER(uartRxBuff, UART1_RX_BUFFER_SIZE);
NEW_CIRC_BUFFER(uartErrBuff, UART1_RX_BUFFER_SIZE);

static int uartErrorCount = 0;
static bool uartFifoOverrun = false;

// returns the actual baud rate.
int Uart1Init(int baud, bool useParity, bool oddParity)
{

	// ***************************************************************
	// To use this function for other USARTS, you should only
	// need to change the code between these 2 star lines.

	USART_TypeDef *USART = USART1;

	// ensure USART Clock is Enabled
	RCC->APB2ENR |= RCC_APB2ENR_USART1EN;
	// select HSI clock source
	RCC->CFGR3 |= RCC_CFGR3_USART1SW_HSI;
	// **************************************************************

	NVIC_DisableIRQ(USART1_IRQn); // disable the interrupt in NVIC

	// deterimine required word length
	uint32_t wordLength = 0;
	uint32_t parityControlEnable = 0;
	uint32_t paritySelection = 0;
	if (useParity)
	{

#ifndef USART_CR1_M0
		// the stm32F030x6 CMSIS file is broken, it does not declare M1, it just declares M0 as M
		wordLength = USART_CR1_M;
#else
		wordLength = USART_CR1_M0;
#endif

		parityControlEnable = USART_CR1_PCE;
		if (oddParity)
		{
			paritySelection = USART_CR1_PS;
		}
	}

	uint32_t fclk = SystemCoreClock; // we are using system clock/1 as our peripheral clock, change this if required

	// find oversampling rate with the lowest error for the
	// given baud rate
	float error16 = ((float)fclk/(float)baud);
	error16 -= (uint32_t)error16;
	float error8 = ((float)fclk*2.0/(float)baud);
	error8 -= (uint32_t)error8;

	// while we are calculating, find out whether
	// we need to round up, and hold on to the answer
	// for later.
	bool roundUp16=false, roundUp8=false;

	if (error16 >= 0.5)
	{
		error16 = 1.0 - error16;
		roundUp16 = true;
	}

	if (error8 >= 0.5)
	{
		error8 = 1.0 - error8;
		roundUp8 = true;
	}

	uint32_t UARTDIV;
	uint32_t oversamp = 0;

	// determine whether to oversample by 8 or 16
	if (error16 > error8 )
	{
		// oversample by 8
		oversamp = USART_CR1_OVER8;
		UARTDIV = fclk * 2 / baud;
		if (roundUp8)
		{
			UARTDIV += 1;
		}
	}
	else
	{
		// oversample by 16
		UARTDIV = fclk / baud;
		if (roundUp16){
			UARTDIV += 1;
		}
	}

	// cap the divider at the maximum baud rate.
	if (UARTDIV < 16)
	{
		UARTDIV = 16;
	}

	uint32_t appliedBaud;
	// record the actual baud rate that was applied.
	if (oversamp)
	{
		appliedBaud = fclk * 2 / UARTDIV;
	}
	else
	{
		appliedBaud = fclk / UARTDIV;
	}


	USART->CR1 &= ~USART_CR1_UE; // ensure the usart is stopped before attempting to configure

	//TODO: for rs485 we need to set up the DEAT and DEDT times.
	USART->CR1 = oversamp | wordLength | parityControlEnable | paritySelection |
			USART_CR1_TXEIE | USART_CR1_RXNEIE | USART_CR1_IDLEIE | USART_CR1_TE |
			USART_CR1_RE;

	// if 2 stop bits are required, set CR2 to USART_CR2_STOP_1
	USART->CR2 = 0;


	//TODO: the bit DEP in CR3 selects the RS485 driver enable polarity detection.
	// DEP = 1 = active low, DEP = 0 = active high
	//TODO: the bit DEM enables the DE pin (ie. we need DEM = 1 for our RS485 design)
	USART->CR3 = 0;

	// program the baud rate
	if (oversamp)
	{
		uint32_t temp = UARTDIV >> 1;
		temp &= 0b111;
		UARTDIV &= 0xFFFFFFF0;
		USART->BRR = (UARTDIV | temp);
	}
	else
	{
		USART->BRR = UARTDIV;
	}


	// read any dead data from the rx buffer.
	uint8_t temp;
	temp = USART1->RDR;

	// enable the USART
	USART->CR1 |= USART_CR1_UE;

	NVIC_SetPriority(USART1_IRQn,2); // 3 is lowest priority, 0 is highest
	NVIC_EnableIRQ(USART1_IRQn); // enable the interrupt in NVIC


	// return the baud rate that was actually applied
	return appliedBaud;
}

int Uart1TxFree()
{
	// buffer available function is non-atomic,
	// so we need to disable interrupts before
	// calling.
	NVIC_DisableIRQ(USART1_IRQn); // disable the interrupt in NVIC
	return BuffAvail(&uartTxBuff);
	NVIC_EnableIRQ(USART1_IRQn); // enable the interrupt in NVIC
}

int Uart1Tx(uint8_t* data, int len)
{
	int count;
	for (count = 0; count < len; count++)
	{
		if(BuffPush(&uartTxBuff, data+count))
		{
			break;
		}
	}
	return count;
}

int Uart1RxLen()
{
	// buffer level function is non-atomic,
	// so we need to disable interrupts before
	// calling.
	NVIC_DisableIRQ(USART1_IRQn); // disable the interrupt in NVIC
	return BuffLevel(&uartRxBuff);
	NVIC_EnableIRQ(USART1_IRQn); // enable the interrupt in NVIC
}

int Uart1Rx(uint8_t *data, int len)
{
	int count;
	for (count = 0; count < len; count++)
	{
		uint8_t temp;
		temp = 0;
		BuffPop(&uartErrBuff, &temp);
		if (temp) // if the read character has an associated error
		{
			uartErrorCount--; // that error is no longer in the fifo.
		}

		if(BuffPop(&uartRxBuff, data+count))
		{
			// just for safety's sake, make sure
			// the error buffer and count don't
			// fall out of sync with the rx buffer.
			// Clear them both when the rx fifo becomes empty.
			uartErrorCount = 0;
			BuffClear(&uartErrBuff);
			break;
		}
	}
	return count;
}

void Uart1DiscardRxBuffer()
{
	NVIC_DisableIRQ(USART1_IRQn); // disable the interrupt in NVIC
	BuffClear(&uartRxBuff);
	BuffClear(&uartErrBuff);
	uartErrorCount = 0;
	uartFifoOverrun = false;
	NVIC_EnableIRQ(USART1_IRQn); // enable the interrupt in NVIC
}

void Uart1DiscardTxBuffer()
{
	BuffClear(&uartTxBuff);
}

bool Uart1HasRxErrorInFifo() // returns true if one of the bytes in the fifo has an error.
{
	return (uartErrorCount != 0);
}

uint8_t Uart1GetRxErrorFlags() // gets the errors for the byte not yet read from the fifo.
{
	uint8_t temp = 0;
	BuffPeek(&uartErrBuff, &temp);
	return temp;
}

void USART1_IRQHandler(void)
{

	if ((USART1->ISR | USART_ISR_TXE) && (USART1->CR1 & USART_CR1_TXEIE))
	{
		if (BuffPop(&uartTxBuff, (uint8_t*)&USART1->TDR))
		{
			// if there is no data in the TX buffer, then disable the
			// interrupt to prevent recursive interrupts
			USART1->CR1 &= ~USART_CR1_TXEIE;
		}
	}

	// now that USART is read, check and fix ORE flag
	if (USART1->ISR & USART_ISR_ORE)
	{
		//This should never happen, but
		// to be truly correct, we flag
		// overruns here as well.
		uartFifoOverrun = true;
		USART1->ICR = USART_ICR_ORECF;
	}

	if ((USART1->ISR & USART_ISR_RXNE) && (USART1->CR1 & USART_CR1_RXNEIE))
	{
		uint8_t temp = USART1->RDR; // we need this temp to force a read because
									// BuffPush will not read the register if the buffer is full.
		if (BuffPush(&uartRxBuff, &temp))
		{
			// we have an overrun, so flag it
			uartFifoOverrun = true;
		}
		else
		{
			// reuse temp;
			temp = 0;
			if (uartFifoOverrun)
			{
				// an overrun occurred before this byte was received
				temp |= UART_OVERRUN_ERROR;
				uartFifoOverrun = false;
			}

			if (USART1->ISR |= USART_ISR_PE)
			{
				temp |= UART_PARITY_ERROR;
				USART1->ICR = USART_ICR_PECF;
			}

			if (USART1->ISR |= USART_ISR_FE)
			{
				temp |= UART_FRAMING_ERROR;
				USART1->ICR = USART_ICR_FECF;
			}
			if (USART1->ISR |= USART_ISR_NE)
			{
				temp |= UART_NOISE_DETECTED;
				USART1->ICR = USART_ICR_NCF;
			}

			if (temp)
			{
				uartErrorCount++;
			}
			BuffPush(&uartErrBuff, &temp);
		}
	}

	if ((USART1->ISR & USART_ISR_IDLE) && (USART1->CR1 & USART_CR1_IDLEIE))
	{
		// TODO: on idle, force an interrupt to get the buffer to flush
		USART1->CR1 &= ~USART_CR1_IDLEIE;
	}
}



